---
data:
  _extendedDependsOn:
  - icon: ':warning:'
    path: src/analysis/golden_ratio_search.hpp
    title: src/analysis/golden_ratio_search.hpp
  - icon: ':warning:'
    path: src/analysis/ternary_search.hpp
    title: src/analysis/ternary_search.hpp
  - icon: ':warning:'
    path: src/basic/chmax.hpp
    title: src/basic/chmax.hpp
  - icon: ':warning:'
    path: src/basic/chmin.hpp
    title: src/basic/chmin.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/comparison.hpp
    title: src/basic/comparison.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/comparison.hpp
    title: src/basic/comparison.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/comparison.hpp
    title: src/basic/comparison.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/constant.hpp
    title: src/basic/constant.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/constant.hpp
    title: src/basic/constant.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/constant.hpp
    title: src/basic/constant.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/constant.hpp
    title: src/basic/constant.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/constant.hpp
    title: src/basic/constant.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/constant.hpp
    title: src/basic/constant.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/equal.hpp
    title: src/basic/equal.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/equal.hpp
    title: src/basic/equal.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/equal.hpp
    title: src/basic/equal.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/greater_equal.hpp
    title: src/basic/greater_equal.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/greater_equal.hpp
    title: src/basic/greater_equal.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/greater_than.hpp
    title: src/basic/greater_than.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/greater_than.hpp
    title: src/basic/greater_than.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/less_equal.hpp
    title: src/basic/less_equal.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/less_equal.hpp
    title: src/basic/less_equal.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/less_than.hpp
    title: src/basic/less_than.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/less_than.hpp
    title: src/basic/less_than.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/sign.hpp
    title: src/basic/sign.hpp
  - icon: ':heavy_check_mark:'
    path: src/basic/sign.hpp
    title: src/basic/sign.hpp
  - icon: ':warning:'
    path: src/combinatorics/combination.hpp
    title: src/combinatorics/combination.hpp
  - icon: ':warning:'
    path: src/combinatorics/homogenous_product.hpp
    title: src/combinatorics/homogenous_product.hpp
  - icon: ':warning:'
    path: src/combinatorics/permutation.hpp
    title: src/combinatorics/permutation.hpp
  - icon: ':warning:'
    path: src/data_structure/binary_indexed_tree.hpp
    title: src/data_structure/binary_indexed_tree.hpp
  - icon: ':warning:'
    path: src/data_structure/hold_ends.hpp
    title: src/data_structure/hold_ends.hpp
  - icon: ':warning:'
    path: src/data_structure/segment_tree.hpp
    title: src/data_structure/segment_tree.hpp
  - icon: ':heavy_check_mark:'
    path: src/data_structure/union_find.hpp
    title: src/data_structure/union_find.hpp
  - icon: ':warning:'
    path: src/geometry/centroid.hpp
    title: src/geometry/centroid.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/circle.hpp
    title: src/geometry/circle.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/circle.hpp
    title: src/geometry/circle.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/circumcircle.hpp
    title: src/geometry/circumcircle.hpp
  - icon: ':warning:'
    path: src/geometry/concyclic.hpp
    title: src/geometry/concyclic.hpp
  - icon: ':warning:'
    path: src/geometry/degree_to_radian.hpp
    title: src/geometry/degree_to_radian.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/distance.hpp
    title: src/geometry/distance.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/distance.hpp
    title: src/geometry/distance.hpp
  - icon: ':warning:'
    path: src/geometry/excircle.hpp
    title: src/geometry/excircle.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/incircle.hpp
    title: src/geometry/incircle.hpp
  - icon: ':warning:'
    path: src/geometry/intersect.hpp
    title: src/geometry/intersect.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/line.hpp
    title: src/geometry/line.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/line.hpp
    title: src/geometry/line.hpp
  - icon: ':warning:'
    path: src/geometry/normal_vector.hpp
    title: src/geometry/normal_vector.hpp
  - icon: ':warning:'
    path: src/geometry/orthocenter.hpp
    title: src/geometry/orthocenter.hpp
  - icon: ':warning:'
    path: src/geometry/orthogonal_check.hpp
    title: src/geometry/orthogonal_check.hpp
  - icon: ':warning:'
    path: src/geometry/parallel_check.hpp
    title: src/geometry/parallel_check.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/point.hpp
    title: src/geometry/point.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/point.hpp
    title: src/geometry/point.hpp
  - icon: ':warning:'
    path: src/geometry/projection.hpp
    title: src/geometry/projection.hpp
  - icon: ':warning:'
    path: src/geometry/radian_to_degree.hpp
    title: src/geometry/radian_to_degree.hpp
  - icon: ':warning:'
    path: src/geometry/rotate.hpp
    title: src/geometry/rotate.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/segment.hpp
    title: src/geometry/segment.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/segment.hpp
    title: src/geometry/segment.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/triangle.hpp
    title: src/geometry/triangle.hpp
  - icon: ':heavy_check_mark:'
    path: src/geometry/triangle.hpp
    title: src/geometry/triangle.hpp
  - icon: ':warning:'
    path: src/geometry/unit_vector.hpp
    title: src/geometry/unit_vector.hpp
  - icon: ':warning:'
    path: src/graph/edge.hpp
    title: src/graph/edge.hpp
  - icon: ':warning:'
    path: src/graph/find_cycle_by_dfs.hpp
    title: src/graph/find_cycle_by_dfs.hpp
  - icon: ':warning:'
    path: src/graph/topological_sort.hpp
    title: src/graph/topological_sort.hpp
  - icon: ':warning:'
    path: src/matrix/matrix_operation.hpp
    title: src/matrix/matrix_operation.hpp
  - icon: ':warning:'
    path: src/matrix/matrix_rotate.hpp
    title: src/matrix/matrix_rotate.hpp
  - icon: ':warning:'
    path: src/number_theory/base_change.hpp
    title: src/number_theory/base_change.hpp
  - icon: ':warning:'
    path: src/number_theory/divisors.hpp
    title: src/number_theory/divisors.hpp
  - icon: ':heavy_check_mark:'
    path: src/number_theory/dynamic_modint.hpp
    title: src/number_theory/dynamic_modint.hpp
  - icon: ':warning:'
    path: src/number_theory/eratosthenes_sieve.hpp
    title: src/number_theory/eratosthenes_sieve.hpp
  - icon: ':heavy_check_mark:'
    path: src/number_theory/greatest_common_divisor.hpp
    title: src/number_theory/greatest_common_divisor.hpp
  - icon: ':warning:'
    path: src/number_theory/linear_sieve.hpp
    title: src/number_theory/linear_sieve.hpp
  - icon: ':heavy_check_mark:'
    path: src/number_theory/modint.hpp
    title: src/number_theory/modint.hpp
  - icon: ':warning:'
    path: src/number_theory/naive_sieve.hpp
    title: src/number_theory/naive_sieve.hpp
  - icon: ':warning:'
    path: src/number_theory/prime_check.hpp
    title: src/number_theory/prime_check.hpp
  - icon: ':warning:'
    path: src/number_theory/prime_check.hpp
    title: src/number_theory/prime_check.hpp
  - icon: ':question:'
    path: src/number_theory/prime_factorization.hpp
    title: src/number_theory/prime_factorization.hpp
  - icon: ':warning:'
    path: src/number_theory/sundaram_sieve.hpp
    title: src/number_theory/sundaram_sieve.hpp
  - icon: ':warning:'
    path: src/sorting/bubble_sort.hpp
    title: src/sorting/bubble_sort.hpp
  - icon: ':warning:'
    path: src/sorting/insertion_sort.hpp
    title: src/sorting/insertion_sort.hpp
  - icon: ':warning:'
    path: src/string/clip_string.hpp
    title: src/string/clip_string.hpp
  - icon: ':warning:'
    path: src/string/rotate_string.hpp
    title: src/string/rotate_string.hpp
  - icon: ':warning:'
    path: src/string/run_length_encording.hpp
    title: src/string/run_length_encording.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':warning:'
  attributes:
    links: []
  bundledCode: "#line 1 \"src/all.hpp\"\n\n\n\n#line 1 \"src/analysis/golden_ratio_search.hpp\"\
    \n\n\n\n#line 1 \"src/basic/comparison.hpp\"\n\n\n\n#line 1 \"src/basic/equal.hpp\"\
    \n\n\n\n#line 1 \"src/basic/sign.hpp\"\n\n\n\n#line 1 \"src/basic/constant.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\nconst long double EPS = 10e-12;\nconst long\
    \ long int LINF = 1001001001001001001LL;\nconst long double PI = acos(-1);\nconst\
    \ long double GOLDEN_RATIO = 2 * cos(PI / 5);\n\n}  // namespace BanetteGin\n\n\
    \n#line 5 \"src/basic/sign.hpp\"\n\nnamespace BanetteGin {\n\ntemplate <class\
    \ T>\nint sign(const T& x) {\n    return (x < -EPS ? -1 : (x < EPS ? 0 : 1));\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 5 \"src/basic/equal.hpp\"\n\nnamespace\
    \ BanetteGin {\n\ntemplate <class T>\nbool equal(const T &a, const T &b) {\n \
    \   return (sign(a - b) == 0);\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"\
    src/basic/greater_equal.hpp\"\n\n\n\nnamespace BanetteGin {\n\ntemplate <class\
    \ T>\nbool greater_equal(const T &a, const T &b) {\n    return (sign(a - b) >=\
    \ 0);\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/basic/greater_than.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\nbool greater_than(const\
    \ T &a, const T &b) {\n    return (sign(a - b) > 0);\n}\n\n}  // namespace BanetteGin\n\
    \n\n#line 1 \"src/basic/less_equal.hpp\"\n\n\n\nnamespace BanetteGin {\n\ntemplate\
    \ <class T>\nbool less_equal(const T &a, const T &b) {\n    return (sign(a - b)\
    \ <= 0);\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/basic/less_than.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\nbool less_than(const T &a,\
    \ const T &b) {\n    return (sign(a - b) < 0);\n}\n\n}  // namespace BanetteGin\n\
    \n\n#line 9 \"src/basic/comparison.hpp\"\n\n\n#line 5 \"src/analysis/golden_ratio_search.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T, class Function>\nT golden_ratio_search(T\
    \ left, T right, Function func, bool option = true) {\n    T mid1 = left + (right\
    \ - left) * GOLDEN_RATIO / (2 * GOLDEN_RATIO + 1);\n    T mid2 = left + (right\
    \ - left) * (GOLDEN_RATIO + 1) / (2 * GOLDEN_RATIO + 1);\n    while (!equal(left,\
    \ right)) {\n        if (option) {\n            if (less_equal(func(mid1), func(mid2)))\
    \ {\n                right = mid2;\n                mid2 = mid1;\n           \
    \     mid1 = left + (right - left) * GOLDEN_RATIO / (2 * GOLDEN_RATIO + 1);\n\
    \            } else {\n                left = mid1;\n                mid1 = mid2;\n\
    \                mid2 = left + (right - left) * (GOLDEN_RATIO + 1) / (2 * GOLDEN_RATIO\
    \ + 1);\n            }\n        } else {\n            if (greater_equal(func(mid1),\
    \ func(mid2))) {\n                right = mid2;\n                mid2 = mid1;\n\
    \                mid1 = left + (right - left) * GOLDEN_RATIO / (2 * GOLDEN_RATIO\
    \ + 1);\n            } else {\n                left = mid1;\n                mid1\
    \ = mid2;\n                mid2 = left + (right - left) * (GOLDEN_RATIO + 1) /\
    \ (2 * GOLDEN_RATIO + 1);\n            }\n        }\n    }\n    return left;\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/analysis/ternary_search.hpp\"\
    \n\n\n\n#line 6 \"src/analysis/ternary_search.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T, class Function>\nT ternary_search(T left, T right, Function\
    \ func, bool option = true) {\n    while (!equal(left, right)) {\n        T mid1\
    \ = left + (right - left) / 3;\n        T mid2 = left + (right - left) / 3 * 2;\n\
    \        if (option) {\n            if (less_equal(func(mid1), func(mid2)))\n\
    \                right = mid2;\n            else\n                left = mid1;\n\
    \        } else {\n            if (greater_equal(func(mid1), func(mid2)))\n  \
    \              right = mid2;\n            else\n                left = mid1;\n\
    \        }\n    }\n    return left;\n}\n\n}  // namespace BanetteGin\n\n\n#line\
    \ 1 \"src/basic/chmax.hpp\"\n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\n\
    bool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return\
    \ 1;\n    }\n    return 0;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/basic/chmin.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\nbool chmin(T& a, const T&\
    \ b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return\
    \ 0;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/combinatorics/combination.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\nT combination(const T& m,\
    \ const T& n) {\n    assert(m >= n);\n    T ret = 1;\n    for (long long int i\
    \ = m; i >= m - n + 1; --i) {\n        ret = ret * i;\n    }\n    for (long long\
    \ int i = n; i >= 1; --i) {\n        ret = ret / i;\n    }\n    return ret;\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/combinatorics/homogenous_product.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\nT homogenous_product(const\
    \ T& m, const T& n) {\n    T ret = 1;\n    for (long long int i = m + n - 1; i\
    \ >= m; --i) {\n        ret = ret * i;\n    }\n    for (long long int i = m -\
    \ 1; i >= 1; --i) {\n        ret = ret / i;\n    }\n    return ret;\n}\n\n}  //\
    \ namespace BanetteGin\n\n\n#line 1 \"src/combinatorics/permutation.hpp\"\n\n\n\
    \nnamespace BanetteGin {\n\ntemplate <class T>\nT permutation(const T& m, const\
    \ T& n) {\n    T ret = 1;\n    for (long long int i = m; i >= m - n + 1; --i)\
    \ {\n        ret = ret * i;\n    }\n    return ret;\n}\n\n}  // namespace BanetteGin\n\
    \n\n#line 1 \"src/data_structure/binary_indexed_tree.hpp\"\n\n\n\n#include <vector>\n\
    \nnamespace BanetteGin {\n\ntemplate <class T>\nstruct binary_indexed_tree {\n\
    \    T n;\n    std::vector<T> tree;\n    const T ide = 0;\n\n    binary_indexed_tree(T\
    \ n_)\n        : n(n_) {\n        tree.resize(n, ide);\n    }\n\n    T abel_operation(const\
    \ T& x, const T& y) const noexcept {\n        return x + y;\n    }\n\n    T sum(const\
    \ T& l, const T& r) const noexcept {\n        return sum_sub(r) - sum_sub(l -\
    \ 1);\n    }\n\n    T sum_sub(const T& a) const noexcept {\n        T ret = 0;\n\
    \        for (; a >= 0; a = (a & (a + 1)) - 1) ret = abel_operation(ret, tree[a]);\n\
    \        return ret;\n    }\n\n    void add(const T& a, const T& x) noexcept {\n\
    \        for (; a < n; a |= a + 1) tree[a] = abel_operation(tree[a], x);\n   \
    \     return;\n    }\n};\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/data_structure/hold_ends.hpp\"\
    \n\n\n\n#line 5 \"src/data_structure/hold_ends.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\nstruct hold_ends {\n    T k;\n    std::multiset<T> high_end,\
    \ high_other;\n    std::multiset<T> low_end, low_other;\n    T all_sum = 0, high_sum\
    \ = 0, low_sum = 0;\n\n    hold_ends(T k_)\n        : k(k_) {\n    }\n    void\
    \ normalize() {\n        while (high_end.size() < k && !high_other.empty()) {\n\
    \            high_sum += *high_other.rbegin();\n            high_end.insert(*high_other.rbegin());\n\
    \            high_other.erase(high_other.find(*high_other.rbegin()));\n      \
    \  }\n        while (high_end.size() > k) {\n            high_sum -= *high_end.begin();\n\
    \            high_other.insert(*high_end.begin());\n            high_end.erase(high_end.begin());\n\
    \        }\n        while (low_end.size() < k && !low_other.empty()) {\n     \
    \       low_sum += *low_other.begin();\n            low_end.insert(*low_other.begin());\n\
    \            low_other.erase(low_other.begin());\n        }\n        while (low_end.size()\
    \ > k) {\n            low_sum -= *low_end.rbegin();\n            low_other.insert(*low_end.rbegin());\n\
    \            low_end.erase(low_end.find(*low_end.rbegin()));\n        }\n    \
    \    return;\n    }\n    void insert(T x) {\n        all_sum += x;\n        high_sum\
    \ += x;\n        low_sum += x;\n        high_end.insert(x);\n        low_end.insert(x);\n\
    \        normalize();\n    }\n    void erase(T x) {\n        all_sum -= x;\n \
    \       if (high_end.find(x) != high_end.end()) {\n            high_sum -= x;\n\
    \            high_end.erase(high_end.find(x));\n        } else if (high_other.find(x)\
    \ != high_other.end()) {\n            high_other.erase(high_other.find(x));\n\
    \        }\n        if (low_end.find(x) != low_end.end()) {\n            low_sum\
    \ -= x;\n            low_end.erase(low_end.find(x));\n        } else if (low_other.find(x)\
    \ != low_other.end()) {\n            low_other.erase(low_other.find(x));\n   \
    \     }\n        normalize();\n    }\n    std::vector<T> high_array() {\n    \
    \    std::vector<T> ret;\n        for (auto itr = high_end.begin(); itr != high_end.end();\
    \ itr++)\n            ret.emplace_back(*itr);\n        return ret;\n    }\n  \
    \  std::vector<T> low_array() {\n        std::vector<T> ret;\n        for (auto\
    \ itr = low_end.begin(); itr != low_end.end(); itr++)\n            ret.emplace_back(*itr);\n\
    \        return ret;\n    }\n};\n\n}  // namespace BanetteGin\n\n\n#line 1 \"\
    src/data_structure/segment_tree.hpp\"\n\n\n\n#line 5 \"src/data_structure/segment_tree.hpp\"\
    \n\n#line 7 \"src/data_structure/segment_tree.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\nstruct segment_tree {\n    T n;\n    std::vector<T> node;\n\
    \    const T ide = LINF;\n\n    segment_tree(std::vector<T> a) {\n        n =\
    \ 1;\n        while (n < a.size()) n *= 2;\n        node.resize(2 * n - 1, ide);\n\
    \        for (T i = 0; i < a.size(); i++) node[(n - 1) + i] = a[i];\n        for\
    \ (T i = n - 2; i >= 0; i--) {\n            node[i] = monoid_operation(node[i\
    \ * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n\n    T monoid_operation(const\
    \ T& a, const T& b) const noexcept {\n        return min(a, b);\n    }\n\n   \
    \ void update(const T& p, const T& x) noexcept {\n        p += n - 1;\n      \
    \  node[p] = x;\n        while (p > 0) {\n            p = (p - 1) / 2;\n     \
    \       node[p] = monoid_operation(node[2 * p + 1], node[2 * p + 2]);\n      \
    \  }\n    }\n\n    T find(const T& l, const T& r) const noexcept {\n        return\
    \ find_sub(l, r, 0, 0, n);\n    }\n\n    T find_sub(const T& a, const T& b, const\
    \ T& now, const T& l, const T& r) const noexcept {\n        if (b <= l || r <=\
    \ a) return ide;\n        if (a <= l && r <= b) return node[now];\n        T nl\
    \ = find_sub(a, b, 2 * now + 1, l, (l + r) / 2);\n        T nr = find_sub(a, b,\
    \ 2 * now + 2, (l + r) / 2, r);\n        return monoid_operation(nl, nr);\n  \
    \  }\n};\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/data_structure/union_find.hpp\"\
    \n\n\n\n#line 5 \"src/data_structure/union_find.hpp\"\n\nnamespace BanetteGin\
    \ {\n\ntemplate <class T>\nstruct union_find {\n    std::vector<T> par, rk, sz;\n\
    \    union_find(T n)\n        : par(n, -1), rk(n, 0), sz(n, 1) {\n    }\n    T\
    \ root(const T& v) noexcept {\n        if (par[v] == -1)\n            return v;\n\
    \        else\n            return par[v] = root(par[v]);\n    }\n    bool same(const\
    \ T& u, const T& v) noexcept {\n        return root(u) == root(v);\n    }\n  \
    \  bool unite(const T& u, const T& v) noexcept {\n        T urt = root(u);\n \
    \       T vrt = root(v);\n        if (urt == vrt) return false;\n        if (rk[urt]\
    \ < rk[vrt]) swap(urt, vrt);\n        par[vrt] = urt;\n        if (rk[urt] ==\
    \ rk[vrt]) rk[urt]++;\n        sz[urt] += sz[vrt];\n        return true;\n   \
    \ }\n    T size(const T& v) const noexcept {\n        return sz[root(v)];\n  \
    \  }\n};\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/centroid.hpp\"\
    \n\n\n\n#line 1 \"src/geometry/triangle.hpp\"\n\n\n\n#line 1 \"src/geometry/distance.hpp\"\
    \n\n\n\n#line 1 \"src/geometry/line.hpp\"\n\n\n\n#line 1 \"src/geometry/point.hpp\"\
    \n\n\n\n#include <complex>\n\n#line 7 \"src/geometry/point.hpp\"\n\nnamespace\
    \ BanetteGin {\n\ntemplate <class T>\nstruct point {\n    T x, y;\n    point(T\
    \ x_, T y_)\n        : x(x_), y(y_) {\n    }\n\n    point operator+(const point&\
    \ p) const noexcept {\n        return point<T>(this->x + p.x, this->y + p.y);\n\
    \    }\n    point operator-(const point& p) const noexcept {\n        return point<T>(this->x\
    \ - p.x, this->y - p.y);\n    }\n    point operator*(const T& a) const noexcept\
    \ {\n        return point<T>(this->x * a, this->y * a);\n    }\n    point operator/(const\
    \ T& a) const noexcept {\n        return point<T>(this->x / a, this->y / a);\n\
    \    }\n\n    point& operator+=(const point& p) noexcept {\n        this->x +=\
    \ p.x;\n        this->y += p.y;\n        return *this;\n    }\n    point& operator-=(const\
    \ point& p) noexcept {\n        this->x -= p.x;\n        this->y -= p.y;\n   \
    \     return *this;\n    }\n    point& operator*=(const T& a) noexcept {\n   \
    \     this->x *= a;\n        this->y *= a;\n        return *this;\n    }\n   \
    \ point& operator/=(const T& a) noexcept {\n        this->x /= a;\n        this->y\
    \ /= a;\n        return *this;\n    }\n\n    bool operator==(const point& p) const\
    \ noexcept {\n        return equal(this->x, p.x) && equal(this->y, p.y);\n   \
    \ }\n    bool operator!=(const point& p) const noexcept {\n        return !equal(this->x,\
    \ p.x) || !equal(this->y, p.y);\n    }\n    bool operator<(const point& p) const\
    \ noexcept {\n        return !equal(this->x, p.x) || !equal(this->y, p.y);\n \
    \   }\n\n    friend T dot(const point& p, const point& q) noexcept {\n       \
    \ return p.x * q.x + p.y * q.y;\n    }\n    friend T cross(const point& p, const\
    \ point& q) noexcept {\n        return p.x * q.y - p.y * q.x;\n    }\n    friend\
    \ T norm(const point& p) {\n        return sqrt(p.x * p.x + p.y * p.y);\n    }\n\
    \    friend T arg(const point& p) {\n        return atan2(p.y, p.x);\n    }\n\
    };\n\n}  // namespace BanetteGin\n\n\n#line 6 \"src/geometry/line.hpp\"\n\nnamespace\
    \ BanetteGin {\n\ntemplate <class T>\nstruct line {\n    T a, b, c;\n    point<T>\
    \ p, q;\n    line(point<T> p_, point<T> q_)\n        : a(q_.y - p_.y), b(p_.x\
    \ - q_.x), c(-p_.x * q_.y + q_.x * p_.y) {\n        normalize();\n    }\n    line(point<T>\
    \ p_, T m_)\n        : a(m_), b(-1), c(p_.y - m_ * p_.x) {\n        normalize();\n\
    \    }\n    line(T a_, T b_, T c_)\n        : a(a_), b(b_), c(c_) {\n        normalize();\n\
    \    }\n    void normalize() {\n        if (!equal(a, 0)) {\n            b /=\
    \ a;\n            c /= a;\n            a = 1;\n        } else if (!equal(b, 0))\
    \ {\n            b = 1;\n            c /= b;\n        } else {\n            assert(c\
    \ == 0);\n        }\n        bool a_zero = equal(a, 0);\n        bool b_zero =\
    \ equal(b, 0);\n        if (!a_zero && !b_zero) {\n            p = point(-(c /\
    \ a), 0);\n            q = point(0, -(c / b));\n        } else if (!a_zero &&\
    \ b_zero) {\n            p = point(-(c / a), 0);\n            q = point(-(c /\
    \ a), 1);\n        } else if (a_zero && !b_zero) {\n            p = point(1, -(c\
    \ / b));\n            q = point(0, -(c / b));\n        } else if (a_zero && b_zero)\
    \ {\n            p = point(0, 0);\n            q = point(1, 0);\n        }\n \
    \       return;\n    }\n    bool operator==(const line& l) const noexcept {\n\
    \        return equal(this->a, l.a) && equal(this->b, l.b) && equal(this->c, l.c);\n\
    \    }\n    bool operator!=(const line& l) const noexcept {\n        return !equal(this->a,\
    \ l.a) || !equal(this->b, l.b) || !equal(this->c, l.c);\n    }\n};\n\n}  // namespace\
    \ BanetteGin\n\n\n#line 1 \"src/geometry/segment.hpp\"\n\n\n\n#line 6 \"src/geometry/segment.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstruct segment {\n    point<T>\
    \ p, q;\n    T length;\n    segment(point<T> p_, point<T> q_)\n        : p(p_),\
    \ q(q_), length(sqrt(pow(p_.x - q_.x, T(2)) + pow(p_.y - q_.y, T(2)))) {\n   \
    \ }\n};\n\n}  // namespace BanetteGin\n\n\n#line 7 \"src/geometry/distance.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nT distance(point<T> p, point<T>\
    \ q) {\n    return sqrt(pow(p.x - q.x, T(2)) + pow(p.y - q.y, T(2)));\n}\n\ntemplate\
    \ <class T>\nT distance(point<T> p, line<T> l) {\n    return abs(p.x * l.a + p.y\
    \ * l.b + l.c) / sqrt(l.a * l.a + l.b * l.b);\n}\n\ntemplate <class T>\nT distance(point<T>\
    \ p, segment<T> s) {\n}\n\ntemplate <class T>\nT distance(segment<T> s, segment<T>\
    \ t) {\n}\n\n}  // namespace BanetteGin\n\n\n#line 8 \"src/geometry/triangle.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstruct triangle {\n    point<T>\
    \ points[3];\n    T lengths[3];\n    T angles[3];\n    T area;\n    triangle(point<T>\
    \ point_a, point<T> point_b, point<T> point_c)\n        : points{point_a, point_b,\
    \ point_c} {\n        for (int a = 0; a < 3; ++a) {\n            int b, c;\n \
    \           bool added_flag = false;\n            for (int i = 0; i < 3; ++i)\
    \ {\n                if (a != i) {\n                    if (!added_flag) {\n \
    \                       b = i;\n                        added_flag = true;\n \
    \                   } else\n                        c = i;\n                }\n\
    \            }\n            lengths[a] = distance(points[b], points[c]);\n   \
    \     }\n\n        for (int a = 0; a < 3; ++a) {\n            int b, c;\n    \
    \        bool added_flag = false;\n            for (int i = 0; i < 3; ++i) {\n\
    \                if (a != i) {\n                    if (!added_flag) {\n     \
    \                   b = i;\n                        added_flag = true;\n     \
    \               } else\n                        c = i;\n                }\n  \
    \          }\n            angles[a] = acos((pow(lengths[b], 2) + pow(lengths[c],\
    \ 2) - pow(lengths[a], 2)) / (2 * lengths[b] * lengths[c]));\n        }\n\n  \
    \      area = lengths[1] * lengths[2] * sin(angles[0]) / 2;\n    };\n    triangle(T\
    \ length_a, T length_b, T length_c)\n        : lengths{length_a, length_b, length_c}\
    \ {\n        for (int a = 0; a < 3; ++a) {\n            int b, c;\n          \
    \  bool added_flag = false;\n            for (int i = 0; i < 3; ++i) {\n     \
    \           if (a != i) {\n                    if (!added_flag) {\n          \
    \              b = i;\n                        added_flag = true;\n          \
    \          } else\n                        c = i;\n                }\n       \
    \     }\n            angles[a] = acos((pow(lengths[b], 2) + pow(lengths[c], 2)\
    \ - pow(lengths[a], 2)) / (2 * lengths[b] * lengths[c]));\n        }\n\n     \
    \   points[0] = point(0, 0);\n        points[1] = point(0, lengths[1]);\n    \
    \    points[2] = point(lengths[2] * cos(angles[0]), lengths[2] * sin(angles[0]));\n\
    \n        area = lengths[1] * lengths[2] * sin(angles[0]) / 2;\n    };\n};\n\n\
    }  // namespace BanetteGin\n\n\n#line 5 \"src/geometry/centroid.hpp\"\n\nnamespace\
    \ BanetteGin {\n\ntemplate <class T>\npoint<T> centroid(triangle<T> t) {\n   \
    \ return (t.points[0] + t.points[1] + t.points[2]) / 3;\n}\n\n}  // namespace\
    \ BanetteGin\n\n\n#line 1 \"src/geometry/circle.hpp\"\n\n\n\n#line 9 \"src/geometry/circle.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstruct circle {\n    point<T>\
    \ p;\n    T r;\n    circle(point<T> p_, T r_)\n        : p(p_), r(r_) {\n    }\n\
    \    circle(point<T> p_, point<T> q_)\n        : p(p_), r(distance(p_, q_)) {\n\
    \    }\n    circle(point<T> p_, point<T> q_, point<T> r_)\n        : p(constracter_circumcircle(triangle(p_,\
    \ q_, r_)).p), r(constracter_circumcircle(triangle(p_, q_, r_)).r) {\n    }\n\
    \    bool operator==(const circle& c) const noexcept {\n        return equal(this->p,\
    \ c.p) && equal(this->r, c.r);\n    }\n    bool operator!=(const circle& c) const\
    \ noexcept {\n        return !equal(this->p, c.p) || !equal(this->r, c.r);\n \
    \   }\n\nprivate:\n    circle<T> constracter_circumcircle(triangle<T> t) {\n \
    \       point ret = point(0.0L, 0.0L);\n        T denom = 0.0L;\n        for (int\
    \ i = 0; i < 3; ++i) {\n            ret += t.points[i] * sin(2 * t.angles[i]);\n\
    \            denom += sin(2 * t.angles[i]);\n        }\n        T r = t.lengths[0]\
    \ / sin(t.angles[0]) / 2;\n        return circle(ret / denom, r);\n    }\n};\n\
    \n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/circumcircle.hpp\"\n\n\
    \n\n#line 6 \"src/geometry/circumcircle.hpp\"\n\nnamespace BanetteGin {\n\ntemplate\
    \ <class T>\ncircle<T> circumcircle(triangle<T> t) {\n    point ret = point(T(0),\
    \ T(0));\n    for (int i = 0; i < 3; ++i) {\n        T mlt = 0;\n        for (int\
    \ j = 0; j < 3; ++j) {\n            if (i == j)\n                mlt += -pow(t.lengths[j],\
    \ T(2));\n            else\n                mlt += pow(t.lengths[j], T(2));\n\
    \        }\n        mlt *= pow(t.lengths[i], T(2));\n        ret += t.points[i]\
    \ * mlt;\n    }\n    T r = t.lengths[0] / sin(t.angles[0]) / T(2);\n    return\
    \ circle(ret / (T(16) * pow(t.area, T(2))), r);\n}\n\n}  // namespace BanetteGin\n\
    \n\n#line 1 \"src/geometry/concyclic.hpp\"\n\n\n\n#line 5 \"src/geometry/concyclic.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nbool concyclic(std::vector<T>\
    \ points) {\n    assert(points.size() >= 3);\n    if (points.size() == 3) return\
    \ true;\n    T theta = triangle(points[0], points[1], points[2]).angles[2];\n\
    \    for (long long int i = 3; i < points.size(); ++i) {\n        if (triangle(points[0],\
    \ points[1], points[i]).angles[2] != theta) return false;\n    }\n    return true;\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/degree_to_radian.hpp\"\
    \n\n\n\n#line 5 \"src/geometry/degree_to_radian.hpp\"\n\nnamespace BanetteGin\
    \ {\n\ntemplate <class T>\nT degree_to_radian(T theta) {\n    return theta / 180\
    \ * PI;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/excircle.hpp\"\
    \n\n\n\n#line 6 \"src/geometry/excircle.hpp\"\n\nnamespace BanetteGin {\n\ntemplate\
    \ <class T>\ncircle<T> excircle(triangle<T> t, int option = 0) {\n    assert(0\
    \ <= option && option <= 2);\n    point ret = point(T(0), T(0));\n    T denom\
    \ = T(0);\n    for (int i = 0; i < 3; ++i) {\n        T sgn = 1.0;\n        if\
    \ (i == option) sgn = -1.0;\n        ret += t.points[i] * sgn * t.lengths[i];\n\
    \        denom += sgn * t.lengths[i];\n    }\n\n    T r = t.area * T(2) / denom;\n\
    \    return circle(ret / denom, r);\n}\n\n}  // namespace BanetteGin\n\n\n#line\
    \ 1 \"src/geometry/incircle.hpp\"\n\n\n\n#line 6 \"src/geometry/incircle.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\ncircle<T> incircle(triangle<T>\
    \ t) {\n    point ret = point(T(0), T(0));\n    T denom = T(0);\n    for (int\
    \ i = 0; i < 3; ++i) {\n        ret += t.points[i] * t.lengths[i];\n        denom\
    \ += t.lengths[i];\n    }\n    T r = t.area * T(2) / denom;\n    return circle(ret\
    \ / denom, r);\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/intersect.hpp\"\
    \n\n\n\n#line 7 \"src/geometry/intersect.hpp\"\n\nnamespace BanetteGin {\n\ntemplate\
    \ <class T>\nint intersect(const line<T>& l, const circle<T>& c) {\n    T d =\
    \ distance(c.p, l);\n    if (greater_than(d, c.r)) {\n        return 2;\n    }\n\
    \    if (equal(d, c.r)) {\n        return 1;\n    }\n    return 0;\n}\n\ntemplate\
    \ <class T>\nint intersect(const circle<T>& c1, const circle<T>& c2) {\n    T\
    \ d = distance(c1.p, c2.p);\n    if (greater_than(d, c1.r + c2.r)) {\n       \
    \ return 4;\n    }\n    if (greater_than(d, c1.r + c2.r)) {\n        return 3;\n\
    \    }\n    if (equal(d, abs(c1.r - c2.r))) {\n        return 1;\n    }\n    if\
    \ (less_than(d, abs(c1.r - c2.r))) {\n        return 0;\n    }\n    return 2;\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/normal_vector.hpp\"\
    \n\n\n\n#line 5 \"src/geometry/normal_vector.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\npoint<T> normal_vector(const point<T>& p) {\n    return\
    \ p * point(0, 1);\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/orthocenter.hpp\"\
    \n\n\n\n#line 5 \"src/geometry/orthocenter.hpp\"\n\nnamespace BanetteGin {\n\n\
    template <class T>\npoint<T> orthocenter(triangle<T> t) {\n    point ret = point(0.0L,\
    \ 0.0L);\n    T denom = 0.0L;\n    for (int i = 0; i < 3; ++i) {\n        ret\
    \ += t.points[i] * tan(t.angles[i]);\n        denom += tan(t.angles[i]);\n   \
    \ }\n    return ret / denom;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"\
    src/geometry/orthogonal_check.hpp\"\n\n\n\n#line 6 \"src/geometry/orthogonal_check.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nbool orthogonal_check(const\
    \ line<T>& l, const line<T>& m) {\n    return equal(l.a * l.b + m.a * m.b, 0);\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/parallel_check.hpp\"\
    \n\n\n\n#line 6 \"src/geometry/parallel_check.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\nbool parallel_check(const line<T>& l, const line<T>& m)\
    \ {\n    return equal(l.a * m.b - l.b * m.a, 0);\n}\n\n}  // namespace BanetteGin\n\
    \n\n#line 1 \"src/geometry/projection.hpp\"\n\n\n\n#line 6 \"src/geometry/projection.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\npoint<T> projection(const point<T>\
    \ p, const line<T>& l) {\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/radian_to_degree.hpp\"\
    \n\n\n\n#line 5 \"src/geometry/radian_to_degree.hpp\"\n\nnamespace BanetteGin\
    \ {\n\ntemplate <class T>\nT radian_to_degree(T theta) {\n    return theta / PI\
    \ * 180;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/rotate.hpp\"\
    \n\n\n\n#line 5 \"src/geometry/rotate.hpp\"\n\nnamespace BanetteGin {\n\ntemplate\
    \ <class T>\npoint<T> rotate(const point<T>& p, const T& theta) {\n    return\
    \ point<T>(cos(theta) * p.x - sin(theta) * p.y, sin(theta) * p.x + cos(theta)\
    \ * p.y);\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/geometry/unit_vector.hpp\"\
    \n\n\n\n#line 5 \"src/geometry/unit_vector.hpp\"\n\nnamespace BanetteGin {\n\n\
    template <class T>\npoint<T> unit_vector(const point<T>& p) {\n    return p /\
    \ norm(p);\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/graph/edge.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\nstruct edge {\n    T u,\
    \ v, c;\n    edge(T u_, T v_, T c_)\n        : u(u_), v(v_), c(c_) {\n    }\n\
    };\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/graph/find_cycle_by_dfs.hpp\"\
    \n\n\n\n#line 5 \"src/graph/find_cycle_by_dfs.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\nbool find_cycle_by_dfs(T v, std::vector<bool> &visited,\
    \ std::vector<bool> &finished, const std::vector<std::vector<T>> &g) {\n    visited[v]\
    \ = true;\n    for (T nv : g[v]) {\n        if (visited[nv]) continue;\n     \
    \   if (finished[nv]) continue;\n        if (visited[nv] && !finished[nv]) return\
    \ true;\n        if (find_cycle_by_dfs(nv, visited, finished, g)) return true;\n\
    \    }\n    finished[v] = true;\n    return false;\n}\n\n}  // namespace BanetteGin\n\
    \n\n#line 1 \"src/graph/topological_sort.hpp\"\n\n\n\n#line 5 \"src/graph/topological_sort.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstd::vector<T> topological_sort(const\
    \ std::vector<std::vector<T> >& g) {\n    std::vector<T> ret;\n    std::vector<T>\
    \ ind(g.size(), 0);\n    for (long long int i = 0; i < ind.size(); ++i) {\n  \
    \      for (T e : g[i]) ind[e]++;\n    }\n    std::queue<T> q;\n    for (long\
    \ long int i = 0; i < ind.size(); ++i) {\n        if (ind[i] == 0) q.push(i);\n\
    \    }\n    while (!q.empty()) {\n        T nv = q.front();\n        ret.push_back(nv);\n\
    \        q.pop();\n        for (T e : g[nv]) {\n            ind[e]--;\n      \
    \      if (ind[e] == 0) q.push(e);\n        }\n    }\n    return ret;\n}\n\n}\
    \  // namespace BanetteGin\n\n\n#line 1 \"src/matrix/matrix_operation.hpp\"\n\n\
    \n\n#line 5 \"src/matrix/matrix_operation.hpp\"\n\nnamespace BanetteGin {\n\n\
    template <class T>\nstruct matrix_operation {\n    const T addide = 0;\n    const\
    \ T mulide = 1;\n    std::vector<std::vector<T> > a, b;\n    matrix_operation(std::vector<std::vector<T>\
    \ > a_, std::vector<std::vector<T> > b_)\n        : a(a_), b(b_) {\n         \
    \   assert(a.size()>0&&a[0].size>0);\n            assert(b.size()>0&&b[0].size>0);\n\
    \    }\n    T addition(T& x, T& y) const noexcept {\n        return x + y;\n \
    \   }\n    T multiplication(T& x, T& y) const noexcept {\n        return x * y;\n\
    \    }\n    std::vector<std::vector<T> > addition() const noexcept {\n       \
    \ assert(a.size() == b.size() && a[0].size() == b[0].size());\n\n        std::vector<std::vector<T>\
    \ > c(a.size(), std::vector<T>(a[0].size(), addide));\n        for (long long\
    \ int i = 0; i < a.size(); ++i) {\n            for (long long int j = 0; j < a[i].size();\
    \ ++j) {\n                c[i][j] = addition(a[i][j], b[i][j]);\n            }\n\
    \        }\n        return c;\n    }\n    std::vector<std::vector<T> > product()\
    \ const noexcept {\n        assert(a.size() == b[0].size() && a[0].size() == b.size());\n\
    \        std::vector<std::vector<T> > c(a.size(), std::vector<T>(b[0].size(),\
    \ addide));\n        for (long long int i = 0; i < a.size(); ++i) {\n        \
    \    for (long long int j = 0; j < b[0].size(); ++j) {\n                for (long\
    \ long int k = 0; k < b.size(); ++k) {\n                    c[i][j] = addition(c[i][j],\
    \ multiplication(a[i][k], b[k][j]));\n                }\n            }\n     \
    \   }\n        return c;\n    }\n};\n\n}  // namespace BanetteGin\n\n\n#line 1\
    \ \"src/matrix/matrix_rotate.hpp\"\n\n\n\n#line 5 \"src/matrix/matrix_rotate.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstd::vector<std::vector<T>>\
    \ matrix_rotate(std::vector<std::vector<T>> a) {\n    std::vector<std::vector<T>>\
    \ ret;\n    for (long long int i = 0; i < a[0].size(); ++i) {\n        std::vector<T>\
    \ b;\n        for (long long int j = 0; j < a.size(); ++j) {\n            b.emplace_back(a[j][a[0].size()\
    \ - 1 - i]);\n        }\n        ret.emplace_back(b);\n    }\n    return ret;\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/number_theory/base_change.hpp\"\
    \n\n\n\n#include <string>\n\nnamespace BanetteGin {\n\ntemplate <class T>\nstd::string\
    \ base_change(const std::string& num, T m, T n) {\n    reverse(num.begin(), num.end());\n\
    \    T p = 1;\n    T covnum = 0;\n    for (long long int i = 0; i < num.size();\
    \ ++i) {\n        covnum += (T)(num[i] - '0') * p;\n        p = p * m;\n    }\n\
    \    T max_np = 1;\n    while (max_np <= covnum) {\n        max_np *= n;\n   \
    \ }\n    std::string ret = \"\";\n    while (max_np != 0) {\n        ret.push_back((covnum\
    \ / max_np) + '0');\n        covnum %= max_np;\n        max_np /= n;\n    }\n\
    \    return ret;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/number_theory/divisors.hpp\"\
    \n\n\n\n#line 5 \"src/number_theory/divisors.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\nstd::vector<T> divisors(T n) {\n    std::vector<T> ret;\n\
    \    for (long long int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n\
    \            if (i == n / i) {\n                ret.emplace_back(i);\n       \
    \     } else {\n                ret.emplace_back(i);\n                ret.emplace_back(n\
    \ / i);\n            }\n        }\n    }\n    sort(ret.begin(), ret.end());\n\
    \    return ret;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/number_theory/dynamic_modint.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <long long int id>\nstruct dynamic_modint\
    \ {\n    long long int val;\n    dynamic_modint(long long int v = 0) noexcept\n\
    \        : val(v % get_mod()) {\n        if (val < 0) val += get_mod();\n    }\n\
    \    static long long int& get_mod() {\n        static long long int MOD = 1;\n\
    \        return MOD;\n    }\n    static void set_mod(long long int MOD_) {\n \
    \       get_mod() = MOD_;\n        return;\n    }\n    dynamic_modint operator-()\
    \ const noexcept {\n        return val ? get_mod() - val : 0;\n    }\n\n    dynamic_modint\
    \ operator+(const dynamic_modint& r) const noexcept {\n        return dynamic_modint(*this)\
    \ += r;\n    }\n    dynamic_modint operator-(const dynamic_modint& r) const noexcept\
    \ {\n        return dynamic_modint(*this) -= r;\n    }\n    dynamic_modint operator*(const\
    \ dynamic_modint& r) const noexcept {\n        return dynamic_modint(*this) *=\
    \ r;\n    }\n    dynamic_modint operator/(const dynamic_modint& r) const noexcept\
    \ {\n        return dynamic_modint(*this) /= r;\n    }\n\n    dynamic_modint&\
    \ operator+=(const dynamic_modint& r) noexcept {\n        val += r.val;\n    \
    \    if (val >= get_mod()) val -= get_mod();\n        return *this;\n    }\n \
    \   dynamic_modint& operator-=(const dynamic_modint& r) noexcept {\n        val\
    \ -= r.val;\n        if (val < 0) val += get_mod();\n        return *this;\n \
    \   }\n    dynamic_modint& operator*=(const dynamic_modint& r) noexcept {\n  \
    \      val = val * r.val % get_mod();\n        return *this;\n    }\n    dynamic_modint&\
    \ operator/=(const dynamic_modint& r) noexcept {\n        long long int a = r.val,\
    \ b = get_mod(), u = 1, v = 0;\n        while (b) {\n            long long int\
    \ t = a / b;\n            a -= t * b;\n            std::swap(a, b);\n        \
    \    u -= t * v;\n            std::swap(u, v);\n        }\n        val = val *\
    \ u % get_mod();\n        if (val < 0) val += get_mod();\n        return *this;\n\
    \    }\n\n    dynamic_modint& operator++() noexcept {\n        return dynamic_modint(*this)\
    \ += 1;\n    }\n    dynamic_modint& operator--() noexcept {\n        return dynamic_modint(*this)\
    \ -= 1;\n    }\n\n    bool operator==(const dynamic_modint& r) const noexcept\
    \ {\n        return this->val == r.val;\n    }\n    bool operator!=(const dynamic_modint&\
    \ r) const noexcept {\n        return this->val != r.val;\n    }\n\n    friend\
    \ std::ostream& operator<<(std::ostream& os, const dynamic_modint& x) noexcept\
    \ {\n        return os << x.val;\n    }\n\n    friend std::istream& operator>>(std::istream&\
    \ is, dynamic_modint& x) noexcept {\n        long long int t;\n        is >> t;\n\
    \        x = dynamic_modint(t);\n        return (is);\n    }\n\n    friend dynamic_modint<id>\
    \ modpow(const dynamic_modint& a, long long int n) noexcept {\n        if (n ==\
    \ 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n     \
    \   if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n}  // namespace BanetteGin\n\
    \n\n#line 1 \"src/number_theory/eratosthenes_sieve.hpp\"\n\n\n\n#line 5 \"src/number_theory/eratosthenes_sieve.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstd::vector<T> eratosthenes_sieve(T\
    \ n) {\n    std::vector<bool> ret(n + 1, true);\n    std::vector<T> prime_list;\n\
    \    ret[0] = ret[1] = false;\n    for (long long int i = 2; i * i <= n; ++i)\
    \ {\n        if (!ret[i]) continue;\n        for (long long int j = i * 2; j <=\
    \ n; j += i) {\n            ret[j] = false;\n        }\n    }\n    for (long long\
    \ int i = 2; i <= n; ++i) {\n        if (ret[i]) prime_list.emplace_back(i);\n\
    \    }\n    return prime_list;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"\
    src/number_theory/greatest_common_divisor.hpp\"\n\n\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\nT greatest_common_divisor(T a, T b) {\n    return b == 0\
    \ ? a : greatest_common_divisor(b, a % b);\n}\n\n}  // namespace BanetteGin\n\n\
    \n#line 1 \"src/number_theory/linear_sieve.hpp\"\n\n\n\n#line 5 \"src/number_theory/linear_sieve.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstd::vector<T> linear_sieve(T\
    \ n) {\n    std::vector<T> prime_list;\n    std::vector<T> lpf(n + 1, n + 1);\n\
    \    lpf[0] = 1;\n    lpf[1] = 1;\n    for (long long int i = 2; i <= n; ++i)\
    \ {\n        if (lpf[i] == n + 1) {\n            lpf[i] = i;\n            prime_list.emplace_back(i);\n\
    \        }\n        for (long long int j = 0; j < prime_list.size(); ++j) {\n\
    \            T p = prime_list[j];\n            if (p * i > n || p > lpf[i]) break;\n\
    \            lpf[p * i] = p;\n        }\n    }\n    return prime_list;\n}\n\n\
    }  // namespace BanetteGin\n\n\n#line 1 \"src/number_theory/modint.hpp\"\n\n\n\
    \nnamespace BanetteGin {\n\ntemplate <long long int MOD>\nstruct modint {\n  \
    \  long long int val;\n    modint(long long int v = 0) noexcept\n        : val(v\
    \ % MOD) {\n        if (val < 0) val += MOD;\n    }\n    long long int get_mod()\
    \ const noexcept {\n        return MOD;\n    }\n\n    modint operator+(const modint&\
    \ r) const noexcept {\n        return modint(*this) += r;\n    }\n    modint operator-(const\
    \ modint& r) const noexcept {\n        return modint(*this) -= r;\n    }\n   \
    \ modint operator*(const modint& r) const noexcept {\n        return modint(*this)\
    \ *= r;\n    }\n    modint operator/(const modint& r) const noexcept {\n     \
    \   return modint(*this) /= r;\n    }\n\n    modint& operator+=(const modint&\
    \ r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n\
    \        return *this;\n    }\n    modint& operator-=(const modint& r) noexcept\
    \ {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n\
    \    }\n    modint& operator*=(const modint& r) noexcept {\n        val = val\
    \ * r.val % MOD;\n        return *this;\n    }\n\n    modint& operator++() noexcept\
    \ {\n        return modint(*this) += 1;\n    }\n    modint& operator--() noexcept\
    \ {\n        return modint(*this) -= 1;\n    }\n\n    modint& operator/=(const\
    \ modint& r) noexcept {\n        long long int a = r.val, b = MOD, u = 1, v =\
    \ 0;\n        while (b) {\n            long long int t = a / b;\n            a\
    \ -= t * b;\n            std::swap(a, b);\n            u -= t * v;\n         \
    \   std::swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val\
    \ < 0) val += MOD;\n        return *this;\n    }\n\n    bool operator==(const\
    \ modint& r) const noexcept {\n        return this->val == r.val;\n    }\n   \
    \ bool operator!=(const modint& r) const noexcept {\n        return this->val\
    \ != r.val;\n    }\n\n    friend std::ostream& operator<<(std::ostream& os, const\
    \ modint<MOD>& x) noexcept {\n        return os << x.val;\n    }\n\n    friend\
    \ std::istream& operator>>(std::istream& is, modint<MOD>& x) noexcept {\n    \
    \    long long int t;\n        is >> t;\n        x = modint(t);\n        return\
    \ (is);\n    }\n\n    friend modint<MOD> modpow(const modint<MOD>& a, long long\
    \ int n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a,\
    \ n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n\
    \    }\n};\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/number_theory/naive_sieve.hpp\"\
    \n\n\n\n#line 5 \"src/number_theory/naive_sieve.hpp\"\n\n#line 1 \"src/number_theory/prime_check.hpp\"\
    \n\n\n\nnamespace BanetteGin {\n\ntemplate <class T>\nbool prime_check(T n) {\n\
    \    if (n < 2) return false;\n    if (n != 2 && n % 2 == 0) return false;\n \
    \   for (long long int i = 3; i * i <= n; i += 2)\n        if (n % i == 0) return\
    \ false;\n    return true;\n}\n\n}  // namespace BanetteGin\n\n\n#line 7 \"src/number_theory/naive_sieve.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstd::vector<T> naive_sieve(T\
    \ n) {\n    std::vector<T> prime_list;\n    for (long long int i = 2; i <= n;\
    \ ++i) {\n        if (prime_check(i)) prime_list.emplace_back(i);\n    }\n   \
    \ return prime_list;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/number_theory/prime_factorization.hpp\"\
    \n\n\n\n#line 5 \"src/number_theory/prime_factorization.hpp\"\n\nnamespace BanetteGin\
    \ {\n\ntemplate <class T>\nstd::vector<std::pair<T, T> > prime_factorization(T\
    \ n) {\n    std::vector<std::pair<T, T> > prime_list;\n    for (long long int\
    \ i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            long long\
    \ int e = 0;\n            while (n % i == 0) {\n                n /= i;\n    \
    \            e++;\n            }\n            prime_list.emplace_back(std::make_pair(i,\
    \ e));\n        }\n    }\n    if (n != 1) {\n        prime_list.emplace_back(std::make_pair(n,\
    \ 1));\n    }\n    return prime_list;\n}\n\n}  // namespace BanetteGin\n\n\n#line\
    \ 1 \"src/number_theory/sundaram_sieve.hpp\"\n\n\n\n#line 5 \"src/number_theory/sundaram_sieve.hpp\"\
    \n\nnamespace BanetteGin {\n\ntemplate <class T>\nstd::vector<T> sundaram_sieve(T\
    \ n) {\n    std::vector<bool> ret((n + 1) / 2, true);\n    std::vector<T> prime_list\
    \ = {2};\n    ret[0] = false;\n    T m = ((n + 1) / 2 - 2) / 3;\n    for (long\
    \ long int a = 1; a <= m; ++a) {\n        for (long long int b = 1; b <= a &&\
    \ a + b + 2 * a * b <= (n + 1) / 2 - 1; ++b) {\n            ret[a + b + 2 * a\
    \ * b] = false;\n        }\n    }\n    for (T i = 0; i < ret.size(); ++i) {\n\
    \        if (ret[i]) prime_list.emplace_back(i * 2 + 1);\n    }\n    return prime_list;\n\
    }\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/sorting/bubble_sort.hpp\"\n\
    \n\n\n#line 5 \"src/sorting/bubble_sort.hpp\"\n\nnamespace BanetteGin {\n\ntemplate\
    \ <class T>\nstd::vector<T> bubble_sort(const std::vector<T>& a) {\n    for (long\
    \ long int i = 0; i < a.size(); ++i) {\n        for (long long int j = i + 1;\
    \ j < a.size(); ++j) {\n            if (a[i] > a[j]) swap(a[i], a[j]);\n     \
    \   }\n    }\n    return a;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/sorting/insertion_sort.hpp\"\
    \n\n\n\n#line 5 \"src/sorting/insertion_sort.hpp\"\n\nnamespace BanetteGin {\n\
    \ntemplate <class T>\nstd::vector<T> insertion_sort(const std::vector<T>& a) {\n\
    \    for (long long int i = 1; i < a.size(); ++i) {\n        long long int v =\
    \ a[i];\n        long long int j = i;\n        for (; j > 0; j--) {\n        \
    \    if (a[j] > a[i - 1]) a[j] = a[j - 1];\n        }\n        for (long long\
    \ int j = i + 1; j < a.size(); ++j) {\n            if (a[i] > a[j]) swap(a[i],\
    \ a[j]);\n        }\n    }\n    return a;\n}\n\n}  // namespace BanetteGin\n\n\
    \n#line 1 \"src/string/clip_string.hpp\"\n\n\n\n#line 6 \"src/string/clip_string.hpp\"\
    \n\n#line 8 \"src/string/clip_string.hpp\"\n\nnamespace BanetteGin {\n\nstd::vector<std::string>\
    \ clip_string(const std::vector<std::string>& s, char target) {\n    long long\
    \ int lefx, rigx, lefy, rigy;\n    lefx = lefy = LINF;\n    rigx = rigy = -LINF;\n\
    \    std::vector<std::string> ret;\n    for (long long int i = 0; i < s.size();\
    \ ++i) {\n        for (long long int j = 0; j < s[i].size(); ++j) {\n        \
    \    if (s[i][j] == target) {\n                lefx = std::min(lefx, i);\n   \
    \             rigx = std::max(rigx, i);\n            }\n        }\n    }\n   \
    \ for (long long int i = 0; i < s[0].size(); ++i) {\n        for (long long int\
    \ j = 0; j < s.size(); ++j) {\n            if (s[j][i] == target) {\n        \
    \        lefy = std::min(lefy, i);\n                rigy = std::max(rigy, i);\n\
    \            }\n        }\n    }\n    for (long long int i = lefx; i <= rigx;\
    \ ++i) {\n        std::string t = \"\";\n        for (long long int j = lefy;\
    \ j <= rigy; ++j) {\n            t.push_back(s[i][j]);\n        }\n        ret.emplace_back(t);\n\
    \    }\n    return ret;\n}\n\n}  // namespace BanetteGin\n\n\n#line 1 \"src/string/rotate_string.hpp\"\
    \n\n\n\n#line 6 \"src/string/rotate_string.hpp\"\n\nnamespace BanetteGin {\n\n\
    std::vector<std::string> rotate_string(const std::vector<std::string>& s) {\n\
    \    std::vector<std::string> ret;\n    for (long long int i = 0; i < s[0].size();\
    \ ++i) {\n        std::string t = \"\";\n        for (long long int j = 0; j <\
    \ s.size(); ++j) {\n            t.push_back(s[j][s[0].size() - 1 - i]);\n    \
    \    }\n        ret.emplace_back(t);\n    }\n    return ret;\n}\n\n}  // namespace\
    \ BanetteGin\n\n\n#line 1 \"src/string/run_length_encording.hpp\"\n\n\n\n#line\
    \ 6 \"src/string/run_length_encording.hpp\"\n\nnamespace BanetteGin {\n\nstd::vector<std::pair<char,\
    \ long long int> > run_length_encording(const std::string& s) {\n    std::vector<std::pair<char,\
    \ long long int> > ret;\n    for (long long int i = 0; i < s.size();) {\n    \
    \    long long int j = i + 1;\n        for (; j < s.size() && s[i] == s[j]; j++)\
    \ {\n        }\n        ret.emplace_back(std::make_pair(s[i], j - i));\n     \
    \   i = j;\n    }\n    return ret;\n}\n\n}  // namespace BanetteGin\n\n\n#line\
    \ 65 \"src/all.hpp\"\n\n\n"
  code: '#ifndef BANETTEGIN_ALL_HPP_INCLUDED

    #define BANETTEGIN_ALL_HPP_INCLUDED


    #include "analysis/golden_ratio_search.hpp"

    #include "analysis/ternary_search.hpp"

    #include "basic/chmax.hpp"

    #include "basic/chmin.hpp"

    #include "basic/comparison.hpp"

    #include "basic/constant.hpp"

    #include "basic/equal.hpp"

    #include "basic/greater_equal.hpp"

    #include "basic/greater_than.hpp"

    #include "basic/less_equal.hpp"

    #include "basic/less_than.hpp"

    #include "basic/sign.hpp"

    #include "combinatorics/combination.hpp"

    #include "combinatorics/homogenous_product.hpp"

    #include "combinatorics/permutation.hpp"

    #include "data_structure/binary_indexed_tree.hpp"

    #include "data_structure/hold_ends.hpp"

    #include "data_structure/segment_tree.hpp"

    #include "data_structure/union_find.hpp"

    #include "geometry/centroid.hpp"

    #include "geometry/circle.hpp"

    #include "geometry/circumcircle.hpp"

    #include "geometry/concyclic.hpp"

    #include "geometry/degree_to_radian.hpp"

    #include "geometry/distance.hpp"

    #include "geometry/excircle.hpp"

    #include "geometry/incircle.hpp"

    #include "geometry/intersect.hpp"

    #include "geometry/line.hpp"

    #include "geometry/normal_vector.hpp"

    #include "geometry/orthocenter.hpp"

    #include "geometry/orthogonal_check.hpp"

    #include "geometry/parallel_check.hpp"

    #include "geometry/point.hpp"

    #include "geometry/projection.hpp"

    #include "geometry/radian_to_degree.hpp"

    #include "geometry/rotate.hpp"

    #include "geometry/segment.hpp"

    #include "geometry/triangle.hpp"

    #include "geometry/unit_vector.hpp"

    #include "graph/edge.hpp"

    #include "graph/find_cycle_by_dfs.hpp"

    #include "graph/topological_sort.hpp"

    #include "matrix/matrix_operation.hpp"

    #include "matrix/matrix_rotate.hpp"

    #include "number_theory/base_change.hpp"

    #include "number_theory/divisors.hpp"

    #include "number_theory/dynamic_modint.hpp"

    #include "number_theory/eratosthenes_sieve.hpp"

    #include "number_theory/greatest_common_divisor.hpp"

    #include "number_theory/linear_sieve.hpp"

    #include "number_theory/modint.hpp"

    #include "number_theory/naive_sieve.hpp"

    #include "number_theory/prime_check.hpp"

    #include "number_theory/prime_factorization.hpp"

    #include "number_theory/sundaram_sieve.hpp"

    #include "sorting/bubble_sort.hpp"

    #include "sorting/insertion_sort.hpp"

    #include "string/clip_string.hpp"

    #include "string/rotate_string.hpp"

    #include "string/run_length_encording.hpp"


    #endif'
  dependsOn:
  - src/analysis/golden_ratio_search.hpp
  - src/basic/comparison.hpp
  - src/basic/equal.hpp
  - src/basic/sign.hpp
  - src/basic/constant.hpp
  - src/basic/greater_equal.hpp
  - src/basic/greater_than.hpp
  - src/basic/less_equal.hpp
  - src/basic/less_than.hpp
  - src/analysis/ternary_search.hpp
  - src/basic/constant.hpp
  - src/basic/chmax.hpp
  - src/basic/chmin.hpp
  - src/basic/comparison.hpp
  - src/basic/constant.hpp
  - src/basic/equal.hpp
  - src/basic/greater_equal.hpp
  - src/basic/greater_than.hpp
  - src/basic/less_equal.hpp
  - src/basic/less_than.hpp
  - src/basic/sign.hpp
  - src/combinatorics/combination.hpp
  - src/combinatorics/homogenous_product.hpp
  - src/combinatorics/permutation.hpp
  - src/data_structure/binary_indexed_tree.hpp
  - src/data_structure/hold_ends.hpp
  - src/data_structure/segment_tree.hpp
  - src/basic/constant.hpp
  - src/data_structure/union_find.hpp
  - src/geometry/centroid.hpp
  - src/geometry/triangle.hpp
  - src/basic/equal.hpp
  - src/geometry/distance.hpp
  - src/geometry/line.hpp
  - src/basic/comparison.hpp
  - src/geometry/point.hpp
  - src/geometry/segment.hpp
  - src/geometry/circle.hpp
  - src/geometry/circumcircle.hpp
  - src/geometry/circle.hpp
  - src/geometry/concyclic.hpp
  - src/geometry/degree_to_radian.hpp
  - src/basic/constant.hpp
  - src/geometry/distance.hpp
  - src/geometry/excircle.hpp
  - src/geometry/incircle.hpp
  - src/geometry/intersect.hpp
  - src/geometry/line.hpp
  - src/geometry/normal_vector.hpp
  - src/geometry/orthocenter.hpp
  - src/geometry/orthogonal_check.hpp
  - src/geometry/parallel_check.hpp
  - src/geometry/point.hpp
  - src/geometry/projection.hpp
  - src/geometry/radian_to_degree.hpp
  - src/geometry/rotate.hpp
  - src/geometry/segment.hpp
  - src/geometry/triangle.hpp
  - src/geometry/unit_vector.hpp
  - src/graph/edge.hpp
  - src/graph/find_cycle_by_dfs.hpp
  - src/graph/topological_sort.hpp
  - src/matrix/matrix_operation.hpp
  - src/matrix/matrix_rotate.hpp
  - src/number_theory/base_change.hpp
  - src/number_theory/divisors.hpp
  - src/number_theory/dynamic_modint.hpp
  - src/number_theory/eratosthenes_sieve.hpp
  - src/number_theory/greatest_common_divisor.hpp
  - src/number_theory/linear_sieve.hpp
  - src/number_theory/modint.hpp
  - src/number_theory/naive_sieve.hpp
  - src/number_theory/prime_check.hpp
  - src/number_theory/prime_check.hpp
  - src/number_theory/prime_factorization.hpp
  - src/number_theory/sundaram_sieve.hpp
  - src/sorting/bubble_sort.hpp
  - src/sorting/insertion_sort.hpp
  - src/string/clip_string.hpp
  - src/basic/constant.hpp
  - src/string/rotate_string.hpp
  - src/string/run_length_encording.hpp
  isVerificationFile: false
  path: src/all.hpp
  requiredBy: []
  timestamp: '2023-09-08 15:22:49+09:00'
  verificationStatus: LIBRARY_NO_TESTS
  verifiedWith: []
documentation_of: src/all.hpp
layout: document
redirect_from:
- /library/src/all.hpp
- /library/src/all.hpp.html
title: src/all.hpp
---
